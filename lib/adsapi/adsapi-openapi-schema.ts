/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/search/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search ADS
     * @description Do a search.
     *
     *     Query the search engine and return results. All parameters have to be properly url-encoded UTF-8. The response body will always be JSON encoded.
     *
     *     ## Example Search
     *     `q=bibcode:2012A%26A...542A..16R&fl=bibcode,author,pub,identifier,title,property,abstract,keyword,aff`
     *     ## Example Response
     *     ```{
     *       "responseHeader":{
     *         "status":0,
     *         "QTime":3,
     *         "params":{
     *           "q":"bibcode:2012A&A...542A..16R",
     *           "fl":"bibcode,author,pub,identifier,title,property,abstract,keyword",
     *           "start":"0",
     *           "rows":"10",
     *           "wt":"json"}},
     *       "response":{"numFound":1,"start":0,"docs":[
     *         {
     *           "identifier":["2012arXiv1204.4485R",
     *             "2012A&A...542A..16R",
     *             "10.1051/0004-6361/201118723",
     *             "10.1051/0004-6361/201118723",
     *             "arXiv:1204.4485",
     *             "2012arXiv1204.4485R"],
     *           "abstract":"X-ray surveys contain sizable numbers [...],
     *           "property":["ARTICLE",
     *             "ASSOCIATED",
     *             "DATA",
     *             "EPRINT_OPENACCESS",
     *             "ESOURCE",
     *             "OPENACCESS",
     *             "PUB_OPENACCESS",
     *             "REFEREED"],
     *           "bibcode":"2012A&A...542A..16R",
     *           "author":["Ranalli, P.",
     *             "Comastri, A.",
     *             "Zamorani, G.",
     *             "Cappelluti, N.",
     *             "Civano, F.",
     *             "Georgantopoulos, I.",
     *             "Gilli, R.",
     *             "Schinnerer, E.",
     *             "Smolčić, V.",
     *             "Vignali, C."],
     *           "pub":"Astronomy and Astrophysics",
     *           "keyword":["X-rays: galaxies",
     *             "radio continuum: galaxies",
     *             "galaxies: fundamental parameters",
     *             "galaxies: star formation",
     *             "galaxies: active",
     *             "galaxies: high-redshift",
     *             "Astrophysics - Cosmology and Extragalactic Astrophysics"],
     *           "title":["X-ray properties of radio-selected star forming galaxies in the Chandra-COSMOS survey"]}]
     *       }}
     *     ```
     *     ## Example Search Requests
     *     Query | Explanation
     *     ------|-------------------------------------------------
     *      `q=bibcode:2011ApJ...737..103S` |  Search by bibcode
     *      `q=black+holes&fq=database:astronomy` |  Search for "black holes", restricted to astronomy content
     *      `q=dark+energy&fq=author:"Civano,+F"&sort=citation_count+desc` |  Search for "dark energy", filter by author, sort by citation count
     *     `q=dark+energy&sort=citation_count+desc&fl=bibcode,property` |   Return *bibcode* and *property* values
     *     `q=author:"Kurtz,+M"&fq=property:refereed`|   Limit a search to only refereed articles
     *     `q=transiting+exoplanets&rows=200`|  Search for "transiting exoplanets", get 200 rows
     *     `q=transiting+exoplanets&rows=200&start=201`|   Same search but get the next 200 rows
     *
     */
    get: {
      parameters: {
        query: {
          /**
           * @description Query string; for detailed documentation go to https://ui.adsabs.harvard.edu/help/search/search-syntax
           * @example author%3Amart%C3%ADnez+neutron+star
           */
          q: components['parameters']['q'];
          /** @description Additional filters applied on top of the results of the main query. */
          fq?: components['parameters']['fq'];
          /**
           * @description Comma delimited set of fields to return; default is 'id'
           * @example bibcode,author,title
           */
          fl?: components['parameters']['fl'];
          /** @description For pagination, offset of the first returned result (default=0) */
          start?: components['parameters']['start'];
          /** @description How many records to return for this request (default=10, maximum=2000) */
          rows?: components['parameters']['rows'];
          /** @description The format is 'field' + 'direction' where direction is one of 'asc' or 'desc' and field is any of the valid indexes. The default sorting is by relevance (computed by our search engine). Example\: 'sort=read_count+desc' Some useful fields to sort by may be date, citation_count, or read_count.
           *      */
          sort?: components['parameters']['sort'];
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['SearchResults'];
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Resource not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server too busy */
        499: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/search/qtree': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * (advanced) Search ADS and return a query tree object
     * @description Returns a `query tree` (Abstract Syntax Tree - AST) as understood by our query parser. The structure can be used by external applications to rewrite the query or check its syntactic correctness.
     *
     *     ## Example result
     *     ```JSON
     *     {
     *          "qtree": "\n{\"name\":\"OPERATOR\", \"label\":\"DEFOP\", \"children\": [\n    {\"name\":\"MODIFIER\", \"label\":\"MODIFIER\", \"children\": [\n        {\"name\":\"TMODIFIER\", \"label\":\"TMODIFIER\", \"children\": [\n            {\"name\":\"FIELD\", \"label\":\"FIELD\", \"children\": [\n                {\"name\":\"QNORMAL\", \"label\":\"QNORMAL\", \"children\": [\n                    {\"name\":\"TERM_NORMAL\", \"input\":\"star\", \"start\":0, \"end\":3}]\n                }]\n            }]\n        }]\n    }]\n}",
     *          "responseHeader": {
     *           "status": 0,
     *           "QTime": 6,
     *           "params": {
     *            "q": "star",
     *            "wt": "json",
     *            "fl": "id"
     *           }
     *          }
     *         }
     *     ```
     *
     */
    get: {
      parameters: {
        query: {
          /**
           * @description Query string; for detailed documentation go to https://ui.adsabs.harvard.edu/help/search/search-syntax
           * @example author%3Amart%C3%ADnez+neutron+star
           */
          q: components['parameters']['q'];
          /** @description Additional filters applied on top of the results of the main query. */
          fq?: components['parameters']['fq'];
          /**
           * @description Comma delimited set of fields to return; default is 'id'
           * @example bibcode,author,title
           */
          fl?: components['parameters']['fl'];
          /** @description For pagination, offset of the first returned result (default=0) */
          start?: components['parameters']['start'];
          /** @description How many records to return for this request (default=10, maximum=2000) */
          rows?: components['parameters']['rows'];
          /** @description The format is 'field' + 'direction' where direction is one of 'asc' or 'desc' and field is any of the valid indexes. The default sorting is by relevance (computed by our search engine). Example\: 'sort=read_count+desc' Some useful fields to sort by may be date, citation_count, or read_count.
           *      */
          sort?: components['parameters']['sort'];
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['QTree'];
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Resource not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server too busy */
        499: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/search/bigquery': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search using bigquery
     * @description Search endpoint which accepts a list of many IDs (bibcodes). Supports paging.
     *
     *     This endpoint accepts standard search query parameters and returns standard search results, but it also accepts as input a very large query (i.e. a query that can be expressed only as a list of search criteria, typically IDs). There is currently no limit to the size of the submitted data (besides buffer/time limits imposed by our API frontend); however, there are severe limits on how often you can call this endpoint. Typically, only 100 requests per day per user are allowed.
     *
     *     The `bigquery` is always executed as a filter **after** the main query (to filter out unwanted results and keep only the results specified by the `bigquery`). You may want to use `q=*:*` to filter contents of the whole database, however it is advisable to make the `q` as specific as possible. Broad queries have higher `qTime` (execution time) and that will be counted towards your rate-limit (in the future).
     *
     *     The bigquery filter is *applied only after* the main search (i.e. it limits results of the main search).
     *
     *     ## Example requests
     *
     *     Python
     *
     *     ```
     *       import requests
     *       bibcodes="bibcode\n1907AN....174...59.\n1908PA.....16..445.\n1989LNP...334..242S"
     *       r = requests.post('https://api.adsabs.harvard.edu/v1/search/bigquery',
     *            params={'q':'*:*', 'wt':'json', 'fq':'{!bitset}', 'fl':'bibcode'},
     *            headers={'Authorization': 'Bearer:TOKEN'},
     *            data=bibcodes)
     *     ```
     *
     *     Bash curl
     *
     *     ```
     *       curl 'https://api.adsabs.harvard.edu/v1/search/bigquery?q=*:*&fl=bibcode' \
     *       -X 'POST' -H 'Authorization: Bearer TOKEN' -H 'Content-Type: big-query/csv' \
     *       -d $'bibcode\n1907AN....174...59.\n1908PA.....16..445.\n1989LNP...334..242S'
     *     ```
     *
     */
    post: {
      parameters: {
        query: {
          /**
           * @description Query string; for detailed documentation go to https://ui.adsabs.harvard.edu/help/search/search-syntax
           * @example author%3Amart%C3%ADnez+neutron+star
           */
          q: components['parameters']['q'];
          /** @description Additional filters applied on top of the results of the main query. */
          fq?: components['parameters']['fq'];
          /**
           * @description Comma delimited set of fields to return; default is 'id'
           * @example bibcode,author,title
           */
          fl?: components['parameters']['fl'];
          /** @description For pagination, offset of the first returned result (default=0) */
          start?: components['parameters']['start'];
          /** @description How many records to return for this request (default=10, maximum=2000) */
          rows?: components['parameters']['rows'];
          /** @description The format is 'field' + 'direction' where direction is one of 'asc' or 'desc' and field is any of the valid indexes. The default sorting is by relevance (computed by our search engine). Example\: 'sort=read_count+desc' Some useful fields to sort by may be date, citation_count, or read_count.
           *      */
          sort?: components['parameters']['sort'];
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description Newline separated list of values; the first line specifies the index field, the rest are the search values. <br/> Currently, we allow searching in `bibcode` index only. You can submit `canonical` as well as `alternate` bibcodes - the search will automatically match both. In the future, the list of available indexes may be extended.
       *
       *     Note: to correctly format the POST payload, including the newline (\n) characters, in a bash curl request, use ANSI-C quoting (e.g. `$'...'`) as shown in the examples.
       *      */
      requestBody?: {
        content: {
          'big-query/csv': string;
        };
      };
      responses: {
        200: components['responses']['SearchResults'];
        404: components['responses']['SearchResults'];
        /** @description Server too busy */
        499: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save a query
     * @description Save a query for later execution. Can be either a regular query or a bigquery.
     *
     *     ## Example request
     *
     *     ```bash
     *       $ curl 'https://api.adsabs.harvard.edu/v1/vault/query' -H 'Authorization: Bearer:TOKEN' \
     *         -X POST -d $'{"q":"*:*", "bigquery": "bibcode\\n2015IAUGA..2257982A\\n2015IAUGA..2257768A\\n2015IAUGA..2257639R", "fq": "{!bitset}"}' \
     *         -H 'Content-Type: application/json'
     *
     *       > {"qid": "00b39fe4274760f5d8b348815a661ee2", "numFound": 3}
     *     ```
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON object holding the values to submit.
       *
       *     Note: to correctly format the POST payload if running a bigquery, including the newline (\n) characters, in a bash curl request, use ANSI-C quoting (e.g. `$'...'`) as shown in the examples.
       *      */
      requestBody?: {
        content: {
          'application/json': components['schemas']['vaultObject'];
        };
      };
      responses: {
        200: components['responses']['VaultResponse'];
        /** @description QID object not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/query/{queryId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve information about a stored query
     * @description Retrive information about the previously stored query.
     *
     *     ## Example output
     *
     *     ```JSON
     *     {
     *         "numfound": 9,
     *         "qid": "dcd173130bbbbb957eafd866baf38b2c",
     *         "query": "{\"query\": \"fq=%7B%21bitset%7D&q=%2A%3A%2A\", \"bigquery\": \"bibcode\\n15ASPC..495..40015IAUGA..2257982A\\n2015IAUGA..2257768A\\n2015IAUGA..2257639R\\n2015ASPC..492..208G\\n2015ASPC..492..204F\\n2015ASPC..492..189A\\n2015ASPC..492..150T\\n2015ASPC..492...85E\\n2015ASPC..492...80H\\n2015AAS...22533656H\"}"
     *     }
     *     ```
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description QID returned from the POST operation */
          queryId: components['parameters']['queryId'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['VaultResponse'];
        /** @description QID object not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/execute_query/{queryId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search using a stored query
     * @description Search using the stored query and return the same data as Search API endpoint.
     *
     *     ## Example response
     *
     *     ```JSON
     *       {
     *         "response": {
     *             "docs": [
     *                 {
     *                     "id": "10690723"
     *                 },
     *                 {
     *                     "id": "11057363"
     *                 },
     *                 {
     *                     "id": "10564749"
     *                 },
     *                 {
     *                     "id": "10796089"
     *                 },
     *                 {
     *                     "id": "10867252"
     *                 },
     *                 {
     *                     "id": "10867221"
     *                 },
     *                 {
     *                     "id": "10867251"
     *                 },
     *                 {
     *                     "id": "10867277"
     *                 },
     *                 {
     *                     "id": "11057812"
     *                 }
     *             ],
     *             "numFound": 9,
     *             "start": 0
     *         },
     *         "responseHeader": {
     *             "QTime": 6,
     *             "params": {
     *                 "fl": "id",
     *                 "fq": "{!bitset}",
     *                 "q": "*:*",
     *                 "wt": "json"
     *             },
     *             "status": 0
     *         }
     *       }
     *     ```
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: {
          /** @description You can submit query parameters that override parts of the saved query. */
          jsonobj?: components['schemas']['vaultObject'];
        };
        path: {
          /** @description QID returned from the POST operation */
          queryId: components['parameters']['queryId'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['SearchResults'];
        /** @description QID object not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/query2svg/{queryId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return an SVG for a stored query
     * @description Returns an SVG for a stored query. The image shows the number of results returned by the stored query.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description QID returned from the POST operation */
          queryId: components['parameters']['queryId'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Code of the SVG image */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'image/svg+xml': string;
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/libraries': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View all libraries for a given user
     * @description View all libraries for the user associated with the given API token.
     *
     */
    get: {
      parameters: {
        query?: {
          /** @description start index for response */
          start?: number;
          /** @description number of libraries to return */
          rows?: number;
          /** @description key to sort the libraries by */
          sort?: 'date_created' | 'date_last_modified';
          /** @description order to sort the libraries in */
          order?: 'asc' | 'desc';
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Metadata for all libraries for a given user */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              libraries?: components['schemas']['libraryMetadata'][];
            };
          };
        };
        /** @description No username passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    /**
     * Create a new library
     * @description Create a library for the requesting user. Returns the metadata of the library created.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the metadata and bibcodes of the library to be created.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description (optional) name of the library (must be unique for that user). The default is Untitled Library, with an incremented integer starting with 1 appended.
             *      */
            name?: string;
            /** @description (optional) description of the library. The default is "My ADS library"
             *      */
            description?: string;
            /**
             * @description (optional) set to true to allow public access. The default is false, or a private library
             *
             * @default false
             */
            public?: boolean;
            /** @description (optional) list of bibcodes to add. The default is an empty library
             *      */
            bibcode?: string[];
          };
        };
      };
      responses: {
        /** @description Metadata of the library just created
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              name?: string;
              id?: string;
              description?: string;
              bibcode?: string[];
            };
          };
        };
        /** @description No username passed, or wrong type passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Duplicate library name exists */
        409: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/libraries/{library_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View a single library
     * @description View metadata and contents of a specific library. Takes pagination and field arguments consistent with the "search" endpoint to support sorting and paging for documents within a library. The raw argument passes all bibcodes stored in the library, regardless of whether or not they are currently in ADS.
     *
     */
    get: {
      parameters: {
        query?: {
          /** @description starting document index */
          start?: number;
          /** @description number of documents to return */
          rows?: number;
          /** @description document sort order */
          sort?: string;
          /** @description returned fields */
          fl?: string;
          /** @description returns raw bibcodes from database */
          raw?: boolean;
        };
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Metadata and contents of the given library */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              metadata?: components['schemas']['libraryMetadata'];
              /** @description Array of bibcodes in library */
              documents?: string[];
              /** @description Response from solr, when validating library contents */
              solr?: {
                response?: {
                  docs?: {
                    bibcode?: string;
                  }[];
                  numFound?: number;
                  start?: number;
                };
                responseHeader?: {
                  QTime?: number;
                  params?: {
                    q?: string;
                    fl?: string;
                    start?: string;
                    internal_logging_params?: string;
                    sort?: string;
                    fq?: string;
                    rows?: string;
                    wt?: string;
                  };
                  status?: number;
                };
              };
              /** @description Updates from Solr validation */
              updates?: {
                /** @description Number of bibcodes removed because they are duplicates */
                duplicates_removed?: number;
                /** @description List of dictionaries such that a single element describes the original bibcode (key) and the updated bibcode now being stored (item)
                 *      */
                update_list?: Record<string, never>[];
                /** @description Number of documents modified based on the response from Solr */
                num_updated?: number;
              };
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/libraries/operations/{library_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Perform set operations on one or more libraries
     * @description Perform set operations on one or more libraries. The library_id (string) is the unique identifier of the primary library, as specified in the /libraries GET response. Depending on the operation, a secondary library ID may need to be passed in the post payload.
     *     ## Examples
     *     **Union**: take the union of 3 libraries, using the default description and public settings
     *     ``` bash
     *       $ curl -H "Authorization: Bearer $token" -H "Content-Type: application/json" \
     *         https://api.adsabs.harvard.edu/v1/biblib/libraries/operations/iRZhyhvaSWe0uWwcXKt77w \
     *         -X POST \
     *         -d '{"action": "union", "libraries": ["rdRs4g4AQ522k9TJ2umtVA", "s56fjycaRMKxw6tDEr31XQ"], "name": "New union library"}'
     *     ```
     *
     *     *Response*:
     *
     *     `{"id": "BeUbSWXtTPCaRhRV3nec_w", "bibcode": ["2009A&A...502..515G", "2011ApJ...734...87R", "2010ApJ...710..248C", "2003ApJ...595..665X", "2011ApJ...731L..12S", "2010ApJ...721..505R", "2010ApJ...710L.156R", "2010ApJ...723.1255R", "2006ApJ...639L..51A", "2001AJ....122.2993S", "2010ASPC..423..355R", "2010A&A...518A..59G", "2010ApJ...721L..48K"], "description": "Union of 891661ca-1bda-4967-b4b9-6c1c5cab7bef with [u'rdRs4g4AQ522k9TJ2umtVA', u's56fjycaRMKxw6tDEr31XQ']", "name": "New union library"}`
     *
     *     **Intersection**: take the intersection of 2 libraries, using the default public settings
     *     ``` bash
     *       $ curl -H "Authorization: Bearer $token" -H "Content-Type: application/json" \
     *         https://api.adsabs.harvard.edu/v1/biblib/libraries/operations/BeUbSWXtTPCaRhRV3nec_w \
     *         -X POST \
     *         -d '{"action": "intersection", "libraries": ["rdRs4g4AQ522k9TJ2umtVA"], "name": "New intersection library", "description": "Sample intersection library"}'
     *     ```
     *
     *     *Response*:
     *
     *     `{"id": "8V8DzNqyQuOyTX6RF9x7qQ", "bibcode": ["2001AJ....122.2993S", "2009A&A...502..515G", "2006ApJ...639L..51A", "2010ApJ...710..248C", "2003ApJ...595..665X", "2010A&A...518A..59G", "2011ApJ...731L..12S"], "description": "Sample intersection library", "name": "New intersection library"}`
     *
     *     **Difference**: take the difference of 2 libraries
     *     ``` bash
     *       $ curl -H "Authorization: Bearer $token" -H "Content-Type: application/json" \
     *         https://api.adsabs.harvard.edu/v1/biblib/libraries/operations/BeUbSWXtTPCaRhRV3nec_w \
     *         -X POST \
     *         -d '{"action": "difference", "libraries": ["rdRs4g4AQ522k9TJ2umtVA"], "name": "New difference library", "description": "Sample difference library", "public": true}'
     *     ```
     *
     *     *Response*:
     *
     *     `{"id": "9KBh8sVHQxaVkoPALtoXgg", "bibcode": ["2011ApJ...734...87R", "2010ApJ...723.1255R", "2010ApJ...710L.156R", "2010ASPC..423..355R", "2010ApJ...721L..48K", "2010ApJ...721..505R"], "description": "Sample difference library", "name": "New difference library"}`
     *
     *     **Empty**: empty a library of all of its bibcode contents
     *     ``` bash
     *       $ curl -H "Authorization: Bearer $token" -H "Content-Type: application/json" \
     *         https://api.adsabs.harvard.edu/v1/biblib/libraries/operations/9KBh8sVHQxaVkoPALtoXgg \
     *         -X POST \
     *         -d '{"action": "empty"}'
     *     ```
     *     *Response*:
     *
     *     `{"public": true, "bibcode": [], "name": "New difference library", "description": "Sample difference library"}`
     *
     *     **Copy**: copy the bibcode contents from the primary library to the secondary library (this will not empty the library first)
     *     ``` bash
     *       $ curl -H "Authorization: Bearer $token" -H "Content-Type: application/json" \
     *         https://api.adsabs.harvard.edu/v1/biblib/libraries/operations/BeUbSWXtTPCaRhRV3nec_w \
     *         -X POST \
     *         -d '{"action": "copy", "libraries": ["9KBh8sVHQxaVkoPALtoXgg"]}'
     *     ```
     *
     *     *Response*:
     *
     *     `{"public": true, "bibcode": ["2009A&A...502..515G", "2010ApJ...710L.156R", "2010ApJ...710..248C", "2003ApJ...595..665X", "2011ApJ...731L..12S", "2010ApJ...721..505R", "2011ApJ...734...87R", "2010ApJ...723.1255R", "2006ApJ...639L..51A", "2001AJ....122.2993S", "2010ASPC..423..355R", "2010A&A...518A..59G", "2010ApJ...721L..48K"], "name": "New difference library", "description": "Sample difference library"}`
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID for the primary library */
          library_id: string;
        };
        cookie?: never;
      };
      /** @description JSON containing the action to be performed and metadata of the library to be created.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description Set operation to perform; allowed values are:
             *       * union: take the union of the primary and the secondary
             *       libraries. The result is saved to a new library.
             *       * intersection: take the intersection of the primary and the
             *       secondary libraries. The result is saved to a new library
             *       * difference: take the difference between the primary and the
             *       secondary libraries. The result is saved to a new library
             *       * copy: copy the contents of the primary library into the
             *       secondary library. The secondary library is not emptied first;
             *       use the empty operation on the secondary library first in order
             *       to create a duplicate of the primary library in the secondary library
             *       * empty: empty the primary library of its contents (no secondary
             *       library ID is needed)
             *      */
            action: string;
            /** @description list of secondary library IDs; multiple secondary libraries are allowed for [union, intersection, difference]; one secondary library is allowed for copy; no secondary libraries are allowed for empty
             *      */
            libraries?: string[];
            /** @description name of the new library to be created for [union, intersection, difference]; the name must be unique for a given user; if no name is specified, the name used will be "Untitled" with a timestamp
             *      */
            name?: string;
            /** @description description of the new library to be created for [union, intersection, difference]; if no description is specified, the description used will include the set operation used and the primary and secondary library IDs
             *      */
            description?: string;
            /** @description sets whether the new library created by [union, intersection, difference] is publicly viewable or not; the new library will be private unless otherwise specified
             *      */
            public?: boolean;
          };
        };
      };
      responses: {
        /** @description Metadata for created/modified library */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description ID of created library (if any) */
              id?: string;
              /** @description Name of created/modified library */
              name?: string;
              /** @description Description of created/modified library */
              description?: string;
              /** @description Bibcodes in created/modified library */
              bibcode?: unknown;
            };
          };
        };
        /** @description No username passed, bad library ID passed, wrong type passed, secondary libraries not specified where required, too many secondary libraries specified, or user requested a non-standard operation
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Duplicate library name exists
         *      */
        409: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/documents/{library_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Update the metadata of a library
     * @description Update the metadata of a given library.
     *
     *     The following type of user can edit library metadata:
     *     * owner
     *     * admin
     *
     */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      /** @description JSON containing the metadata to update. If some fields don't need to be changed, they don't need to be included in the payload.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description New name of the library
             *      */
            name?: string;
            /** @description New library description
             *      */
            description?: string;
            /** @description true if the library should be publicly viewable, false if it should be private (note that this is case sensitive and should be lower case)
             *      */
            public?: boolean;
          };
        };
      };
      responses: {
        /** @description Returns the key/value that was requested to be updated
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              name?: string;
              description?: string;
              public?: boolean;
            };
          };
        };
        /** @description No username passed, bad library ID passed, or wrong type passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Duplicate library name exists
         *      */
        409: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Library specified does not exist
         *      */
        410: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /**
     * Add or remove documents from a library
     * @description Add or delete a document to a given library. Returns the number of documents added or removed.
     *
     *     The following type of user can add or remove documents:
     *     * owner
     *     * admin
     *     * write
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      /** @description JSON containing the action to be performed and metadata of the library to be created.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description List of bibcodes to be added or removed
             *      */
            bibcode: string[];
            /** @description 'add' or 'remove' to add or remove the given bibcodes from the specified library
             *      */
            action: string;
          };
        };
      };
      responses: {
        /** @description Returns number of bibcodes added or removed */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Number of bibcodes added, if 'add' is used
               *      */
              number_added?: number;
              /** @description Number of bibcodes removed, if 'remove' is used
               *      */
              number_removed?: number;
              /** @description List of bibcodes that were not found in ADS and could not be added to the library.
               *      */
              invalid_bibcodes?: string[];
            };
          };
        };
        /** @description No username passed, bad library ID passed, wrong type passed, user requested a non-standard operation or user supplied list of bibcodes contained no valid bibcodes.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /**
     * Delete a library
     * @description Delete the given library.
     *
     *     The following type of user can delete the library:
     *     * owner
     *
     */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Returns empty object
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': Record<string, never>;
          };
        };
        /** @description No username passed or bad library ID passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Library specified does not exist
         *      */
        410: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/query/{library_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Add documents to a library by query
     * @description Add documents to a given library by passing a query to the endpoint.
     *
     *     Queries can be performed as they would be using the "search" endpoint with all the same options available to the user.
     *     The following type of user can add or remove documents:
     *     * owner
     *     * admin
     *     * write
     *     ## Example Request
     *     `<library_id>?q=black+holes&fq=database:astronomy`
     *     ## Example Response
     *     ```bash
     *      {"number_added": 10,
     *      "bibcodes":
     *        ["1973PhRvD...7.2333B",
     *         "1973blho.conf..343N",
     *         "1977MNRAS.179..433B",
     *         "2016PhRvL.116f1102A",
     *         "1975CMaPh..43..199H",
     *         "1976PhRvD..14..870U",
     *         "2013ARA&A..51..511K",
     *         "2023MNRAS.518.1057E",
     *         "1973A&A....24..337S",
     *         "1974Natur.248...30H"]}
     *     ```
     *
     */
    get: {
      parameters: {
        query: {
          /**
           * @description Query string; for detailed documentation go to https://ui.adsabs.harvard.edu/help/search/search-syntax
           * @example author%3Amart%C3%ADnez+neutron+star
           */
          q: components['parameters']['q'];
          /** @description Additional filters applied on top of the results of the main query. */
          fq?: components['parameters']['fq'];
          /** @description For pagination, offset of the first returned result (default=0) */
          start?: components['parameters']['start'];
          /** @description How many records to return for this request (default=10, maximum=2000) */
          rows?: components['parameters']['rows'];
          /** @description The format is 'field' + 'direction' where direction is one of 'asc' or 'desc' and field is any of the valid indexes. The default sorting is by relevance (computed by our search engine). Example\: 'sort=read_count+desc' Some useful fields to sort by may be date, citation_count, or read_count.
           *      */
          sort?: components['parameters']['sort'];
        };
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Returns number of bibcodes added or removed */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Number of bibcodes added, if 'add' is used
               *      */
              number_added?: number;
              /** @description List of bibcodes added to the library.
               *      */
              bibcodes?: string[];
            };
          };
        };
        /** @description No username passed, bad library ID passed, wrong type passed, user requested a non-standard operation or user supplied a malformed search query
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Resource not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server too busy */
        499: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Server error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    /**
     * Add or remove documents from a library by query
     * @description Add or delete a documents to a given library based on supplied "search" query parameters. Returns the number of documents added or removed.
     *
     *     The following type of user can add or remove documents:
     *     * owner
     *     * admin
     *     * write
     *     ## Example Payload
     *     `{"params": {"q": "black holes", "fq": "database:astronomy"}, "action": "add"}`
     *     ## Example Response
     *     ```bash
     *      {"number_added": 10,
     *      "bibcodes":
     *        ["1973PhRvD...7.2333B",
     *         "1973blho.conf..343N",
     *         "1977MNRAS.179..433B",
     *         "2016PhRvL.116f1102A",
     *         "1975CMaPh..43..199H",
     *         "1976PhRvD..14..870U",
     *         "2013ARA&A..51..511K",
     *         "2023MNRAS.518.1057E",
     *         "1973A&A....24..337S",
     *         "1974Natur.248...30H"]}
     *     ```
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      /** @description JSON containing the action to be performed and metadata of the library to be created.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description relevant query parameters
             *      */
            params: {
              /** @description The core query string
               *      */
              q: string;
              /** @description query context filtering
               *      */
              fq?: string;
              /** @description The entry number of the query to begin on
               *      */
              start?: number;
              /** @description How many entries to include from the query
               *      */
              rows?: number;
              /** @description The sort order for the returned query
               *      */
              sort?: string;
            };
            /** @description 'add' or 'remove' to add or remove the given query from the specified library
             *      */
            action: string;
          };
        };
      };
      responses: {
        /** @description Returns number of bibcodes added or removed */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Number of bibcodes added, if 'add' is used
               *      */
              number_added?: number;
              /** @description Number of bibcodes removed, if 'remove' is used
               *      */
              number_removed?: number;
              /** @description All bibcodes added from the query
               *      */
              bibcodes?: string[];
            };
          };
        };
        /** @description No username passed, bad library ID passed, wrong type passed, or user requested a non-standard operation User passed a malformed search query.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation.
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/permissions/{library_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View permissions of a library
     * @description View permissions of a specific library.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description List of all permissions for the user for the library */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Key is email of the user, item is a list of that user's permissions for the given library
               *      */
              email?: string[];
            };
          };
        };
        /** @description No username passed, or bad library ID passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    /**
     * Edit permission of a library
     * @description Edit the permissions of a library
     *
     *     The following type of user can add or remove documents:
     *     * owner
     *     * admin
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      /** @description JSON containing the email of the user whose permissions will be modified and the permissions to be added or removed. User may not modify their own permissions
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description Email address of user whose permissions will be modified
             *      */
            email: string;
            /** @description Only required to include permissions that will be modified
             *      */
            permission: {
              read?: boolean;
              write?: boolean;
              admin?: boolean;
            };
          };
        };
      };
      responses: {
        /** @description Returns empty object
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': Record<string, never>;
          };
        };
        /** @description No username passed, bad library ID passed, or wrong type passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have an ADS account
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/biblib/transfer/{library_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer ownership of a library
     * @description Transfer ownership of a library from one user to another
     *
     *     The following type of user can add or remove documents:
     *     * owner
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Library ID */
          library_id: string;
        };
        cookie?: never;
      };
      /** @description JSON containing the email of the user that library ownership will be transferred to
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @description Email address of user who ownership will be transferred to
             *      */
            email: string;
          };
        };
      };
      responses: {
        /** @description Returns empty object
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': Record<string, never>;
          };
        };
        /** @description No username passed, bad library ID passed, or wrong type passed
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have permission to perform this operation
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not have an ADS account
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/bibtexabs/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * BibTeX + abstract export for a single bibcode (GET)
     * @description Export the given bibcode in the BibTeX + abstract format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/bibtexabs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * BibTeX + abstract export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the BibTeX + abstract format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/bibtex/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * BibTeX export for a single bibcode (GET)
     * @description Export the given bibcode in the BibTeX format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/bibtex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * BibTeX export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the BibTeX format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/ads/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * ADS (generic tagged) export for a single bibcode (GET)
     * @description Export the given bibcode in the ADS format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/ads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * ADS (generic tagged) export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the ADS format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/endnote/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * EndNote export for a single bibcode (GET)
     * @description Export the given bibcode in the EndNote format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/endnote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * EndNote export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the EndNote format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/procite/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * ProCite export for a single bibcode (GET)
     * @description Export the given bibcode in the ProCite format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/procite': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * ProCite export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the ProCite format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/ris/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * RIS (Refman) export for a single bibcode (GET)
     * @description Export the given bibcode in the RIS (Refman) format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/ris': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RIS (Refman) export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the RIS (Refman) format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/refworks/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * RefWorks export for a single bibcode (GET)
     * @description Export the given bibcode in the RefWorks format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/refworks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RefWorks export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the RefWorks format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/medlars/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * MEDLARS export for a single bibcode (GET)
     * @description Export the given bibcode in the MEDLARS format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/medlars': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * MEDLARS export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the MEDLARS format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/aastex/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * AASTeX export for a single bibcode (GET)
     * @description Export the given bibcode in the AASTeX format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/aastex': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * AASTeX export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the AASTeX format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/icarus/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Icarus export for a single bibcode (GET)
     * @description Export the given bibcode in the Icarus format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/icarus': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Icarus export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the Icarus format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/mnras/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * MNRAS export for a single bibcode (GET)
     * @description Export the given bibcode in the MNRAS format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/mnras': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * MNRAS export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the MNRAS format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/soph/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Solar Physics (SoPh) export for a single bibcode (GET)
     * @description Export the given bibcode in the Solar Physics (SoPh) format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/soph': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Solar Physics (SoPh) export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the Solar Physics (SoPh) format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/dcxml/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Dublin Core (DC) XML export for a single bibcode (GET)
     * @description Export the given bibcode in the Dublin Core (DC) XML format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/dcxml': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Dublin Core (DC) XML export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the Dublin Core (DC) XML format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/refxml/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * REF-XML export for a single bibcode (GET)
     * @description Export the given bibcode in the REF-XML format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/refxml': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * REF-XML export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the REF-XML format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/refabsxml/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * REFABS-XML export for a single bibcode (GET)
     * @description Export the given bibcode in the REFABS-XML format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/refabsxml': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * REFABS-XML export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the REFABS-XML format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/votable/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * VOTables export for a single bibcode (GET)
     * @description Export the given bibcode in the VOTables format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/votable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * VOTables export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the VOTables format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/rss/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * RSS export for a single bibcode (GET)
     * @description Export the given bibcode in the RSS format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/rss': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RSS export for multiple bibcodes (POST)
     * @description Export the given bibcodes in the RSS format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/rss/{bibcode}/{link}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * RSS export for a single bibcode (GET)
     * @description Export the given bibcode in the RSS format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
          /** @description Query URL */
          link: components['parameters']['link'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/ieee/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * IEEE export (Unicode-encoded) for a single bibcode (GET)
     * @description Export the given bibcode in the IEEE format
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to export */
          bibcode: components['parameters']['bibcode'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ExportResponseGet'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/ieee': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * IEEE export (Unicode-encoded) for multiple bibcodes (POST)
     * @description Export the given bibcodes in the IEEE format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: components['requestBodies']['exportBody'];
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/csl': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * CSL export for one or more bibcodes (POST)
     * @description Export the given bibcodes in the given style and format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the bibcodes to export, and the style and format to export them in.
       *      */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodeObject'] & {
            /**
             * @description Journal style to use
             * @enum {string}
             */
            style: 'aastex' | 'icarus' | 'mnras' | 'soph' | 'aspc' | 'apsj' | 'aasj' | 'ieee';
            /** @description Output format; use 1 for Unicode, 2 for HTML, or 3 for LaTeX */
            format: number;
            /** @description Format of journal name; used only for aastex, aspc, and aasj styles. Use 1 for AASTeX macros (default), 2 for journal abbreviations, or 3 for full journal name.
             *      */
            journalformat?: number;
            /** @description Sort order for export */
            sort?: string;
          };
        };
      };
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/export/custom': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Custom-format export for one or more bibcodes (POST)
     * @description Export the given bibcodes in the given custom format
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the bibcodes to export, and the custom format to export them in.
       *      */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodeObject'] & {
            /** @description Custom format; see the [main export documentation](https://ui.adsabs.harvard.edu/help/actions/export) for more information.
             *      */
            format: string;
          };
        };
      };
      responses: {
        200: components['responses']['ExportResponse'];
        /** @description No result from Solr
         *      */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve metrics for one or more bibcodes
     * @description This endpoint retrieves some or all of the available citation metrics for one or more bibcodes. More documentation is available [here](https://github.com/adsabs/adsabs-dev-api/blob/master/Metrics_API.ipynb).
     *
     *     The available statistics types are:
     *
     *     * 'basic': publication and usage stats (all papers, and just refereed papers); returns 'basic stats' and 'basic stats refereed'
     *     * 'citations': citation stats; returns 'citation stats' and 'citation stats refereed'
     *     * 'indicators': indicators, like the h-index, g-index, m-index, etc.; returns 'indicators' and 'indicators refereed'
     *     * 'histograms': publication, citation, reads and downloads histograms; returns 'histograms'
     *     * 'timeseries': time series for a set of indicators; returns 'time series'
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the bibcode(s) to produce metrics for, as well as types of metrics desired. Depending on the type of metrics requested, other options may be included in the payload.
       *      */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodesObject'] & {
            /** @description Types of metrics to return. If not specified, all metrics will be returned. */
            types?: ('basic' | 'citations' | 'indicators' | 'histograms' | 'timeseries')[];
            /** @description If the metrics type is 'histograms', types of histograms to return. If not specified, all histograms will be returned.
             *
             *     The available histogram types are:
             *
             *     * 'publications': returns 'all publications', 'refereed publications', 'all publications normalized', 'refereed publications normalized'
             *     * 'reads': returns 'all reads', 'refereed reads', 'all reads normalized', 'refereed reads normalized'
             *     * 'downloads': returns 'all downloads', 'refereed downloads', 'all downloads normalized', 'refereed downloads normalized'
             *     * 'citations': returns 'refereed to refereed', 'nonrefereed to refereed', 'refereed to nonrefereed', 'nonrefereed to nonrefereed', 'refereed to refereed normalized', 'nonrefereed to refereed normalized', 'refereed to nonrefereed normalized', 'nonrefereed to nonrefereed normalized'
             *      */
            histograms?: ('publications' | 'reads' | 'downloads' | 'citations')[];
          };
        };
      };
      responses: {
        /** @description JSON containing the requested metrics
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['basicMetricsResponse'] & {
              indicators?: {
                g?: number;
                h?: number;
                i10?: number;
                i100?: number;
                m?: number;
                read10?: number;
                riq?: number;
                tori?: number;
              };
              'indicators refereed'?: {
                g?: number;
                h?: number;
                i10?: number;
                i100?: number;
                m?: number;
                read10?: number;
                riq?: number;
                tori?: number;
              };
              'time series'?: {
                g?: {
                  year?: number;
                };
                h?: {
                  year?: number;
                };
                i10?: {
                  year?: number;
                };
                i100?: {
                  year?: number;
                };
                m?: {
                  year?: number;
                };
                read10?: {
                  year?: number;
                };
                riq?: {
                  year?: number;
                };
                tori?: {
                  year?: number;
                };
              };
            };
          };
        };
        /** @description Unable to get results
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Metrics request blew up */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve metrics for one bibcode
     * @description Similar to the `/metrics` endpoint, but returns data for a single bibcode only. Does not return indicators or timeseries.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to return metrics for */
          bibcode: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON containing the requested metrics
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['basicMetricsResponse'];
          };
        };
        /** @description Unable to get results
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Metrics request blew up */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics/detail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve detail-level metrics for one or more bibcodes
     * @description Provides basic, year-by-year metrics on a per-bibcode basis.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the bibcode(s) to produce metrics for. */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodesObject'];
        };
      };
      responses: {
        /** @description JSON containing the requested metrics */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              bibcode?: {
                citations?: {
                  year?: number;
                };
                downloads?: {
                  year?: number;
                };
                reads?: {
                  year?: number;
                };
                ref_citations?: {
                  year?: number;
                };
              };
              'skipped bibcodes'?: string[];
            };
          };
        };
        /** @description Unable to get results
         *      */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Metrics request blew up */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/author-affiliation/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create the author-affiliations report
     * @description Create the author-affiliations report, generally used for reporting co-authors and their affiliations to grant agencies. Returns information in JSON.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the bibcode(s) to produce the author affiliations for. */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodeObject'] & {
            /** @description First N authors for each paper to report on */
            maxauthor?: number;
            /** @description Last N years to retrieve affiliations for */
            numyears?: number;
          };
        };
      };
      responses: {
        /** @description JSON containing the requested author affiliations */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data?: {
                authorName?: string;
                affiliations?: {
                  name?: string;
                  years?: string[];
                  lastActiveDate?: string;
                };
              }[];
            };
          };
        };
        /** @description Bad request, check payload */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description No result from Solr */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/author-affiliation/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export the author-affiliations report
     * @description Export the author-affiliations report, generally used for reporting co-authors and their affiliations to grant agencies. Outputs to CSV, Excel, text, or directly to the browser/terminal. To save to file, use your terminal's flags or programming language's functionality.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description Formatted report to output, along with format string */
      requestBody?: {
        content: {
          'application/json': {
            /**
             * @description Formatting string for the export.
             *
             * @enum {string}
             */
            format?:
              | '| Lastname, Firstname | Affiliation | Last Active Date | [csv]'
              | '| Lastname | Firstname | Affiliation | Last Active Date | [csv]'
              | '| Lastname, Firstname | Affiliation | Last Active Date | [excel]'
              | '| Lastname | Firstname | Affiliation | Last Active Date | [excel]'
              | 'Lastname, Firstname(Affiliation)Last Active Date[text]'
              | 'Lastname, Firstname(Affiliation)Last Active Date[browser]';
            /** @description Formatted data to export.
             *      */
            selected?: string[];
          };
        };
      };
      responses: {
        /** @description Returns file or text, depending on format requested */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad request, check payload */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/citation_helper': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Suggest missing citations
     * @description Given a set of bibcodes, this endpoint uses a "friends of friends" analysis to suggest up to 10 missing citations. These missing citations cite and/or are cited by the papers in the given list, but are not in the list. The score given with each returned paper reflects how many papers in the input list the result is associated with.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the bibcode(s) to run the citation helper for */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodesObject'];
        };
      };
      responses: {
        /** @description JSON containing the suggested papers */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              author?: string;
              bibcode?: string;
              score?: number;
              title?: string;
            }[];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/harbour/mirrors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch a list of ADS Classic mirrors
     * @description Returns the list of mirrors used by ADS Classic
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Array of available mirrors */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': string[];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/harbour/user': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch user's ADS Classic information
     * @description Returns a user's ADS Classic registration email and mirror
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON containing user's Classic information. User is determined by the API token used.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              classic_email?: string;
              classic_mirror?: string;
              twopointoh_email?: string;
            };
          };
        };
        /** @description User does not have an ADS Classic account */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/harbour/auth/classic': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Sign into ADS Classic account
     * @description Sign into ADS Classic account and link it to your main ADS account
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the user's Classic ADS authentication */
      requestBody?: {
        content: {
          'application/json': {
            classic_email: string;
            classic_mirror: string;
            classic_password: string;
          };
        };
      };
      responses: {
        /** @description JSON containing user's stored Classic information.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              classic_email?: string;
              classic_mirror?: string;
              classic_authed?: boolean;
            };
          };
        };
        /** @description Malformed payload; see error message for details */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Classic authentication failed */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Classic did not return a cookie */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Classic timeout */
        504: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/objects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Return object identifers for a given string
     * @description For a given string, returns the object identifiers from either NED or SIMBAD, whichever is specified
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing either a list of object names ("objects") or a list of SIMBAD object identifiers ("identifiers")
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /**
             * @example SIMBAD
             * @enum {string}
             */
            source?: 'simbad' | 'ned';
            /** @example [
             *       "1575544"
             *     ] */
            identifiers?: string[];
            /** @example [
             *       "M31"
             *     ] */
            objects?: string[];
          };
        };
      };
      responses: {
        /** @description JSON containing the input object or identifier as the key and the values are the canonical names or identifiers. If the object or identifier was not recognized, the value returned with be None.
         *
         *     Note: this service also returns a 200 even if an error was encountered; be sure to read the returned error message carefully in that case.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              'object or identifier'?: {
                /** @description Integer or string, depending on input source */
                id?: string;
                canonical?: string;
              };
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/objects/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Return a Solr query with object identifiers
     * @description For a given object, return a Solr query that expands the object to include the SIMBAD and NED identifiers.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input object query to expand
       *      */
      requestBody?: {
        content: {
          'application/json': {
            query?: string[];
          };
        };
      };
      responses: {
        /** @description JSON containing the expanded search query.
         *
         *     Note: this service also returns a 200 even if an error was encountered; be sure to read the returned error message carefully in that case.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              query?: string;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/journals/summary/{bibstem}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Summary information about a publication indexed by ADS
     * @description For a bibstem, return information about the publication, including the official name and commonly-used variations, publisher and publisher history (when available), and the ISSN and other identifiers when available.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /**
           * @description (Case-sensitive) ADS identifier for a publication, used to create bibcodes
           *
           * @example ApJS
           */
          bibstem: components['parameters']['JournalBibstem'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON object containing `master`, `idents`, `abbrev`, `pubhist`, and `names` objects, which contain summary information about the publication (master), known alphanumeric identifiers (idents), known abbreviations for the title (abbrev), historical information about the journal and its publisher(s) when available (pubhist), and native-language and transliterated names for journals having names in languages other than English, when available (names).
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['summary'];
          };
        };
        /** @description Authentication failure, unable to get results */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Internal error, unable to get results */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/journals/journal/{journalname}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Indexed journals that match a user-supplied search string
     *
     * @description For a user-supplied search string, return a list of publication titles and their accompanying bibstems, if the search string matches one of the title's official name, translated or transliterated names, or a known alternate title or abbreviation.  Spaces ("%20" in URL-encoded format) are treated as substring terminators, such that the returned result of a search for `Astro%20Jour` would include both `Astronomical Journal` and `Astrophysical Journal`.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /**
           * @description Search string
           * @example Astro%20Jour
           */
          journalname: components['parameters']['JournalJournalName'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON list of possible matches containing both bibstem and the publication's formal name of record.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['journal'];
          };
        };
        /** @description Authentication failure, unable to get results */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Internal error, unable to get results */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/journals/holdings/{bibstem}/{volume}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Electronic sources available via the ADS for a given bibstem and volume
     *
     * @description For a user-supplied publication bibstem and volume, return a list of what types of electronic sources are available in our catalog holdings of papers from that publication.  This service doesn't provide the actual links to the paper -- this is intended to provide librarians information at a quick glance what esources are available, including publisher pdf and html, eprints, and ADS-hosted PDF fulltext.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /**
           * @description (Case-sensitive) ADS identifier for a publication, used to create bibcodes
           *
           * @example ApJS
           */
          bibstem: components['parameters']['JournalBibstem'];
          /** @description publication volume */
          volume: components['parameters']['JournalVolume'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON object containing the bibcode, volume, number papers in the volume, and an array of holdings objects containing the page number and an array of esource types.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['holdings'];
          };
        };
        /** @description Authentication failure, unable to get results */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Internal error, unable to get results */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/journals/refsource/{bibstem}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Sources of reference data for given publication
     * @description For a given bibstem, provide a tally of reference sources for each volume for which references exist.  For a publication with references supplied by the publisher for most or all papers, the `publisher` count should approximately match the paper count for that volume.  References may also originate from other sources for individual papers, such as author-supplied (e.g. ArXiv) preprints and OCR by NASA ADS.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /**
           * @description (Case-sensitive) ADS identifier for a publication, used to create bibcodes
           *
           * @example ApJS
           */
          bibstem: components['parameters']['JournalBibstem'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON object containing an array of refsource objects, each of which contains the volume, the year, and a dictionary of refsources containing the refsource type and count.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['refsource'];
          };
        };
        /** @description Authentication failure, unable to get results */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Internal error, unable to get results */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/journals/issn/{issn}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * ADS bibstem for a given ISSN
     * @description For a given ISSN, return a dictionary of the corresponding ADS bibstem, journal name and ISSN type (e.g. print, electronic) if it exists.  If the record is not found, return an empty dictionary.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /**
           * @description Search string
           * @example 0004-637X
           */
          issn: components['parameters']['JournalISSN'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON object containing a dictionary.  If results are found, the dictionary contains the ISSN, ISSN type, ADS bibstem, and journal name of record as key value pairs.  If no results are found, the dictionary is empty.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['issn'];
          };
        };
        /** @description Authentication failure, unable to get results */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Internal error, unable to get results */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/oracle/matchdoc': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Given some input metadata, return the matched bibcode
     * @description Matches input metadata to an existing record and returns the bibcode of the match. Can be used to find the bibcode of an input record or to match various versions of the same record (e.g. the published paper with its arXiv version). Also returned is the confidence score and which input metadata fields were used in the matching.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input data for the recommender service
       *      */
      requestBody?: {
        content: {
          'application/json': {
            abstract: string;
            title: string;
            /** @description Format is "Last1, First1; Last2, First2; ..." */
            author: string;
            /** @description Type can be string or integer */
            year: number;
            /** @description Doctype of input metadata
             *      */
            doctype: string;
            doi?: string;
            /** @description Set flag to true if you know ADS must have this paper; in some cases, the main matching algorithm may fail to find a match (e.g. if the abstract has changed significantly between the arXiv and published version). If this is the case, setting this flag to true allows a match to be made based on the title alone.
             *      */
            mustmatch?: boolean;
            /** @description Expected doctype of matched record
             *      */
            match_doctype?: string[];
          };
        };
      };
      responses: {
        /** @description JSON containing any matches, plus information about the matching process. Confidence and scores range between 0 (low) and 1 (high).
         *
         *     Note: If no matches are found, the service still returns a 200, but instead of the "match" keyword, the "no match" keyword will be returned in the JSON.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Solr query used to find the matches
               *      */
              query?: string;
              /** @description Logging from the matching algorithm
               *      */
              comment?: string;
              match?: {
                bibcode?: string;
                confidence?: number;
                scores?: {
                  abstract?: number;
                  title?: number;
                  author?: number;
                  year?: number;
                };
              }[];
            };
          };
        };
        /** @description No payload provided, or payload is missing needed parameters */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/oracle/readhist': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Return recommendations for the current user
     * @description Returns paper recommendations for the given user, based on their reading history.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input data for the recommender service
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /**
             * @description Second-order operator used to generate recommendations; default is 'similar'
             *
             * @enum {string}
             */
            function: 'similar' | 'trending' | 'reviews' | 'useful';
            /** @description Sort order for recommendation query
             *      */
            sort?: string;
            /** @description Number of recommendations to return
             *      */
            num_docs?: number;
            /** @description Number of input records to use in generating recomendations
             *      */
            top_n_reads?: number;
            /** @description Number of days back to generate recommendations; returned recommendations will have been entered into our database between now and N days ago, where N is the entered cutoff_days
             *      */
            cutoff_days?: number;
            /** @description Internal ID specifying the user; if not included, user will be determined via the API token used
             *      */
            reader?: string;
          };
        };
      };
      responses: {
        /** @description JSON containing the returned recommendations and the query used to generate them
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              bibcodes?: string;
              query?: string;
            };
          };
        };
        /** @description No payload provided, or payload is missing needed parameters */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/oracle/readhist/{function}/{reader}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return recommendations for the given user
     * @description Returns paper recommendations for the given user, based on their reading history.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Second-order operator used to generate recommendations; most common is 'similar'
           *      */
          function: string;
          /** @description Internal ID specifying the user to generate recommendations for
           *      */
          reader: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON containing the returned recommendations and the query used to generate them
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              bibcodes?: string;
              query?: string;
            };
          };
        };
        /** @description Reader was not provided */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reference/text/{reference}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Resolve a reference string into a bibcode
     * @description Given a reference string (such as from the references section of a published paper), returns the bibcode of the matching paper.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /**
           * @description URL-encoded reference string
           * @example Kravchenko%20et%20al.%202020%2C%20A%26A%20637%2C%20L6
           */
          reference: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description JSON containing the input reference, the matching bibcode, and the confidence score
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              resolved?: {
                /** @description Output matching bibcode */
                bibcode?: string;
                /** @description Input reference string */
                refstring?: string;
                /** @description Confidence score, ranging from 0 (low) to 1 (high) */
                score?: string;
                /** @description Error message if parsing fails */
                comment?: string;
              };
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reference/text': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resolve one or more reference strings into a bibcode
     * @description Given one or more reference strings (such as from the references section of a published paper), returns the bibcode(s) of the matching paper(s). Multiple references should be passed as individual strings in a comma-delimited list.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input reference strings
       *      */
      requestBody?: {
        content: {
          'application/json': {
            reference: string[];
          };
        };
      };
      responses: {
        /** @description JSON containing the input reference, the matching bibcode, and the confidence score
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              resolved?: {
                /** @description Output matching bibcode */
                bibcode?: string;
                /** @description Input reference string */
                refstring?: string;
                /** @description Confidence score, ranging from 0 (low) to 1 (high) */
                score?: string;
                /** @description Error message if parsing fails */
                comment?: string;
              };
            };
          };
        };
        /** @description Bad request, check payload */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reference/xml': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resolve one or more parsed references into a bibcode
     * @description Given one or more parsed reference strings, returns the bibcode of the matching paper.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the parsed input references.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @example [
             *       "{'authors': 'Baumjohann, W., Haerendel, G.H.', 'journal': 'Geophysical Monograph', 'title': 'Physics of Magnetic Flux Ropes', 'volume': '58', 'page': '627', 'year': '1990', 'refstr': 'Baumjohann, W., Haerendel, G.H., 1990. Geophysical Monograph, Physics of Magnetic Flux Ropes, 58, 627.', 'refplaintext': 'Baumjohann, W., Haerendel, G.H., 1990. Geophysical Monograph, Physics of Magnetic Flux Ropes, 58, 627.'}"
             *     ] */
            parsed_reference: string[];
          };
        };
      };
      responses: {
        /** @description JSON containing the input reference, the matching bibcode, and the confidence score
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              resolved?: {
                /** @description Output matching bibcode */
                bibcode?: string;
                /** @description Input reference string */
                refstring?: string;
                /** @description Confidence score, ranging from 0 (low) to 1 (high) */
                score?: string;
                /** @description Error message if parsing fails */
                comment?: string;
              };
            };
          };
        };
        /** @description Bad request, check payload */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reference/parse': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Parse one or more input reference strings
     * @description Given one or more reference strings (such as from the references section of a published paper), returns the parsed reference data. Multiple references should be passed as individual strings in a comma-delimited list.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input reference strings
       *      */
      requestBody?: {
        content: {
          'application/json': {
            reference: string[];
          };
        };
      };
      responses: {
        /** @description JSON containing the parsed reference(s)
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              parsed?: {
                authors?: string;
                year?: string;
                volume?: string;
                page?: string;
                journal?: string;
                /** @description Input reference string */
                refstr?: string;
              }[];
            };
          };
        };
        /** @description Bad request, check payload */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resolver/{bibcode}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return links to external resources for a given bibcode
     * @description Return links to external resources, such as a publisher's full text, data links, etc., for a given bibcode
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to return resources for */
          bibcode: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ResolverResponse'];
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Did not find any matching records */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/resolver/{bibcode}/{link_type}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return links to a given external resource for a bibcode
     * @description Return links to a specific external resource, such as a publisher's full text or data links, for a given bibcode
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Bibcode to return resources for */
          bibcode: string;
          /** @description External resource type to return (case-insensitive). The available link types for a given bibcode can be discovered by returning all available resources for a bibcode (via `/resolver/{bibcode}`) and looking at the `type` keywords.
           *     Note: for `link_type` of `arXiv` or `doi`, an additional parameter, the `id` is required. The syntax is `/resolver/{bibcode}/{link_type}:{id}`.
           *
           *     For example:
           *
           *     `/resolver/2010ApJ...713L.103B/doi:10.1088/2041-8205/713/2/L103`
           *
           *     `/resolver/2018arXiv180303598K/arXiv:1803.03598`
           *
           *     Available values for `link_type`:
           *     * `abstract` Abstract
           *     * `citations` Citations to the Article
           *     * `references` References in the Article
           *     * `coreads` Also-Read Articles
           *     * `toc` Table of Contents
           *     * `openurl`
           *     * `metrics`
           *     * `graphics`
           *     * `esource` Full text sources
           *
           *       * `pub_pdf` Publisher PDF
           *
           *       * `eprint_pdf` Arxiv eprint
           *
           *       * `author_pdf` Link to PDF page provided by author
           *
           *       * `ads_pdf` ADS PDF
           *
           *       * `pub_html` Electronic on-line publisher article (HTML)
           *
           *       * `eprint_html` Arxiv article
           *
           *       * `author_html` Link to HTML page provided by author
           *
           *       * `ads_scan` ADS scanned article
           *
           *       * `gif` backward compatibility similar to /ads_scan
           *
           *       * `preprint` backward compatibility similar to /eprint_html
           *
           *       * `ejournal` backward compatibility similar to /pub_html
           *
           *     * `data` On-line data
           *
           *       * `aca` Acta Astronomica Data Files
           *
           *       * `alma` Atacama Large Millimeter/submillimeter Array
           *
           *       * `ari` Astronomisches Rechen-Institut
           *
           *       * `astroverse` CfA Dataverse
           *
           *       * `atnf` Australia Telescope Online Archive
           *
           *       * `author` Author Hosted Dataset
           *
           *       * `bavj` Data of the German Association for Variable Stars
           *
           *       * `bicep2` BICEP/Keck Data
           *
           *       * `cadc` Canadian Astronomy Data Center
           *
           *       * `cds` Strasbourg Astronomical Data Center
           *
           *       * `chandra` Chandra X-Ray Observatory
           *
           *       * `dryad` International Repository of Research Data
           *
           *       * `esa` ESAC Science Data Center
           *
           *       * `eso` European Southern Observatory
           *
           *       * `figshare` Online Open Access Repository
           *
           *       * `gcpd` The General Catalogue of Photometric Data
           *
           *       * `github` Git Repository Hosting Service
           *
           *       * `gtc` Gran Telescopio CANARIAS Public Archive
           *
           *       * `heasarc` NASA's High Energy Astrophysics Science Archive Research Center
           *
           *       * `herschel` Herschel Science Center
           *
           *       * `ibvs` Information Bulletin on Variable Stars
           *
           *       * `ines` IUE Newly Extracted Spectra
           *
           *       * `iso` Infrared Space Observatory
           *
           *       * `jwst` JWST Proposal Info
           *
           *       * `koa` Keck Observatory Archive
           *
           *       * `mast` Mikulski Archive for Space Telescopes
           *
           *       * `ned` NASA/IPAC Extragalactic Database
           *
           *       * `nexsci` NASA Exoplanet Archive
           *
           *       * `noao` National Optical Astronomy Observatory
           *
           *       * `pangaea` Digital Data Library and a Data Publisher for Earth System Science
           *
           *       * `pasa` Publication of the Astronomical Society of Australia Datasets
           *
           *       * `pdg` Particle Data Group
           *
           *       * `pds` The NASA Planetary Data System
           *
           *       * `protocols` Collaborative Platform and Preprint Server for Science Methods and Protocols
           *
           *       * `simbad` SIMBAD Database at the CDS
           *
           *       * `spitzer` Spitzer Space Telescope
           *
           *       * `tns` Transient Name Server
           *
           *       * `vizier` VizieR Catalog Service
           *
           *       * `xmm` XMM Newton Science Archive
           *
           *       * `zenodo` Zenodo Archive
           *
           *     * `inspire` HEP/Spires Information
           *     * `librarycatalog`
           *     * `presentation` Multimedia Presentation
           *     * `associated` Associated Articles
           *      */
          link_type: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ResolverResponse'];
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Did not find any matching records */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/notifications': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View all myADS notifications set up for the current user
     * @description View all myADS notifications set up for the current user, associated with the given API token
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Details of notifications set up for the current user */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['myADSsummaryResponse'][];
          };
        };
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description No notifications found for the given user */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    /**
     * Create a myADS notification
     * @description Create a myADS notification for the current user
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the notifications setup. There are two types of notifications:
       *
       *     * template-type notifications: Notify the user about new papers that match a templated query. The following keywords are required:
       *
       *       * template: The template to use to construct the query. The options are:
       *
       *         * arxiv: Meant for daily frequency; notifies of new arXiv papers. Requires the data and classes keywords:
       *
       *           * classes: (required) Array of arXiv categories and sub-categories to include in notifications
       *
       *           * data: (optional) Formatted search terms to search for within designated classes. If included,
       *             notifications will include all papers that match the given categories, and papers that match
       *             the search terms in this data keyword will be highlighted.
       *
       *         * authors: Meant for weekly frequency; notify the user of up to 5 new papers about given authors.
       *         Requires the data keyword:
       *
       *           * data: (required) Must be formatted as `author:\"Last, First\"` or `orcid:\"ORCID-ID\"`. Can
       *           combine multiple author queries using `OR`
       *
       *         * citations: Meant for weekly frequency; notify the user of new citations to papers by a given author.
       *         Requires the data keyword:
       *
       *           * data: (required) Must be formatted as `author:\"Last, First\"` or `orcid:\"ORCID-ID\"`
       *
       *         * keyword: Meant for weekly frequency; notify the user of new papers matching a given set of
       *         keywords. Three queries are constructed for the given set of search terms: recent papers,
       *         trending papers, and useful papers. Requires the data keyword:
       *
       *           * data: (required) Formatted search terms or keywords
       *
       *     * query-type notifications: These notify the user about new papers that match a given query. The following keywords are required:
       *
       *       * name: Name to call the notification
       *
       *       * qid: Query ID returned from the `/vault/query` endpoint, pointing to the stored query
       *
       *       * frequency: Daily or weekly notification frequency
       *
       *       * stateful: Set to true to only be notified of new papers; set to false to be notified of
       *       the top matches to a query, whether or not you've seen them before
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /** @enum {string} */
            type: 'template' | 'query';
            /** @description Optional for type=template; required for type=query */
            name?: string;
            /** @description Only used for type=query */
            qid?: string;
            /** @description Set to true to receive this notification */
            active?: boolean;
            /** @description Only used for type=query */
            stateful?: boolean;
            /** @enum {string} */
            frequency?: 'daily' | 'weekly';
            /**
             * @description Only used for type=template
             * @enum {string}
             */
            template?: 'arxiv' | 'authors' | 'citations' | 'keyword';
            /** @description Only used for type=template and template=arxiv */
            classes?: string[];
            data?: string;
          };
        };
      };
      responses: {
        /** @description Returns notification setup details */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['myADSsummaryResponse'] &
              components['schemas']['myADSdetailResponse'];
          };
        };
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Query associated with give QID does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not exist or other error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/notifications/{myads_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View the details for one myADS notification
     * @description View the details for one myADS notification set up for the current user, associated with the given API token
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description ID from one myADS notification, taken from the response to `/vault/notifications` */
          myads_id: components['parameters']['myadsId'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Details of none otification set up for the current user */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['myADSsummaryResponse'] &
              components['schemas']['myADSdetailResponse'];
          };
        };
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Notification not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /**
     * Edit the details for one myADS notification
     * @description Edit the details for one myADS notification set up for the current user, associated with the given API token
     *
     */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description ID from one myADS notification, taken from the response to `/vault/notifications` */
          myads_id: components['parameters']['myadsId'];
        };
        cookie?: never;
      };
      /** @description JSON containing metadata of notification to edit.
       *
       *     Note: only need to include information that needs to be changed.
       *      */
      requestBody?: {
        content: {
          'application/json': {
            data?: string;
            name?: string;
            classes?: string[];
            active?: boolean;
            stateful?: boolean;
            /** @enum {string} */
            frequency?: 'daily' | 'weekly';
          };
        };
      };
      responses: {
        /** @description Details of none otification set up for the current user */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['myADSsummaryResponse'] &
              components['schemas']['myADSdetailResponse'];
          };
        };
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Notification not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description User does not exist or other error */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    post?: never;
    /**
     * Delete one myADS notification
     * @description Delete one myADS notification set up for the current user, associated with the given API token
     *
     */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description ID from one myADS notification, taken from the response to `/vault/notifications` */
          myads_id: components['parameters']['myadsId'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Successfully deleted the notification */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Notification not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error during request */
        500: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vault/notification_query/{myads_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return a constructed myADS query
     * @description Given a myADS ID for a single notification setup, use the inputed data to build the full query(ies), ready for execution.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description ID from one myADS notification, taken from the response to `/vault/notifications` */
          myads_id: components['parameters']['myadsId'];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Constructed query and sort parameter. For the keyword and arxiv template-type queries, more than one query and sort parameter will be returned.
         *      */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              q?: string;
              sort?: string;
            }[];
          };
        };
        /** @description Malformed request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Notification not found */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vis/author-network': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Returns author network data
     * @description Used to generate our author network visualization, given an input set of bibcodes, returns the author network data
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input bibcodes
       *      */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodesObject'];
        };
      };
      responses: {
        /** @description Author network data */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              msg?: {
                start?: number;
                rows?: number;
                numFound?: number;
              };
              data?: {
                bibcode_dict?: {
                  bibcode?: {
                    read_count?: number;
                    authors?: string[];
                    citation_count?: number;
                    title?: string;
                  };
                };
                root?: {
                  name?: {
                    nodeName?: string;
                    nodeWeight?: number;
                    delete?: boolean;
                  }[];
                  children?: {
                    read_count?: number;
                    name?: string;
                    citation_count?: number;
                    numberName?: number;
                    papers?: string[];
                    size?: number;
                  }[];
                };
                link_data?: number[][];
              };
            };
          };
        };
        /** @description Error with request */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vis/paper-network': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Returns paper network data
     * @description Used to generate our paper network visualization, given an input set of bibcodes, returns the paper network data
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input bibcodes
       *      */
      requestBody?: {
        content: {
          'application/json': components['schemas']['bibcodesObject'];
        };
      };
      responses: {
        /** @description Paper network data */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              msg?: {
                start?: number;
                rows?: number;
                numFound?: number;
              };
              data?: {
                summaryGraph?: {
                  directed?: boolean;
                  /** @default [] */
                  graph: number[];
                  nodes?: {
                    paper_count?: number;
                    node_label?: {
                      label?: number;
                    };
                    total_citations?: number;
                    node_name?: number;
                    top_common_references?: {
                      bibcode?: number;
                    };
                    total_reads?: number;
                    stable_index?: number;
                    id?: number;
                  }[];
                  links?: {
                    source?: number;
                    target?: number;
                    weight?: number;
                  }[];
                  multigraph?: boolean;
                };
                fullGraph?: {
                  directed?: boolean;
                  /** @default [] */
                  graph: number[];
                  nodes?: {
                    read_count?: number;
                    group?: number;
                    title?: string;
                    first_author?: string;
                    citation_count?: number;
                    node_name?: string;
                    id?: number;
                    nodeWeight?: number;
                  }[];
                  links?: {
                    source?: number;
                    overlap?: string[];
                    weight?: number;
                    target?: number;
                  }[];
                };
              };
            };
          };
        };
        /** @description Error with request */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/vis/word-cloud': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Returns the word cloud data
     * @description Used to generate our word/concept cloud visualization, given an input query, returns the word cloud data
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description JSON containing the input query
       *      */
      requestBody?: {
        content: {
          'application/json': {
            /**
             * @description Query string; can include search tags. If using quotes, make sure to escape them.
             *
             * @example [
             *       "author:\"huchra, john\""
             *     ]
             */
            q?: string[];
            /** @example [
             *       "date desc, bibcode desc"
             *     ] */
            sort?: string[];
            /**
             * @description Number of records to use in generating the word cloud; currently the maximum allowed is 500.
             *
             * @example [
             *       150
             *     ]
             */
            rows?: number[];
          };
        };
      };
      responses: {
        /** @description Word cloud data */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Keywords are the words in the cloud */
              word?: {
                /** @description Inverse document frequency */
                idf?: number;
                record_count?: number;
                total_occurrences?: number;
              };
            };
          };
        };
        /** @description Error with request */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    responseHeader: {
      /** @description Status code as returned by the search engine */
      status?: number;
      /** @description search time in millisecs (only search, without faceting, latency and all other steps) */
      QTime?: number;
      /** @description Input search parameters */
      parameters?: {
        q?: string;
        fl?: string;
        start?: string;
        rows?: string;
      };
    };
    doc: {
      id: string;
      bibcode?: string;
      title?: string;
    };
    results: {
      responseHeader?: components['schemas']['responseHeader'];
      response?: {
        numFound?: number;
        start?: number;
        docs?: components['schemas']['doc'][];
      };
    };
    qtree: {
      responseHeader?: components['schemas']['responseHeader'];
      /** @description serialized JSON */
      qtree?: string;
    };
    /**
     * @description Query string; for detailed documentation go to https://ui.adsabs.harvard.edu/help/search/search-syntax
     * @example author%3Amart%C3%ADnez+neutron+star
     */
    q: unknown;
    /**
     * @description Comma delimited set of fields to return; default is 'id'
     * @example bibcode,author,title
     */
    fl: unknown;
    /** @description For pagination, offset of the first returned result (default=0) */
    start: unknown;
    /** @description How many records to return for this request (default=10, maximum=2000) */
    rows: unknown;
    /** @description The format is 'field' + 'direction' where direction is one of 'asc' or 'desc' and field is any of the valid indexes. The default sorting is by relevance (computed by our search engine). Example\: 'sort=read_count+desc' Some useful fields to sort by may be date, citation_count, or read_count.
     *      */
    sort: unknown;
    vaultObject: {
      q?: components['schemas']['q'];
      fl?: components['schemas']['fl'];
      start?: components['schemas']['start'];
      rows?: components['schemas']['rows'];
      sort?: components['schemas']['sort'];
      /** @description must be set to `'{!bitset}'`
       *      */
      fq?: string;
      /** @description new line separated list of bibcodes, the first line is the name of the index that will be searched, right now we only support search in `bibcode` index
       *      */
      bigquery?: string;
    };
    libraryMetadata: {
      /** @description User who created the library */
      owner?: string;
      /** @description Number of bibcodes in the library */
      num_documents?: number;
      /** @description True means it is public */
      public?: boolean;
      /** @description Number of users with permissions to this library */
      num_users?: number;
      /** @description Date library was created */
      date_created?: string;
      /** @description Name of library */
      name?: string;
      /** @description Description of library */
      description?: string;
      /** @description Permission type, can be 'read', 'write', 'admin', or 'owner' */
      permission?: string;
      /** @description Library ID */
      id?: string;
      /** @description Date library was last modified */
      date_last_modified?: string;
    };
    bibcodeObject: {
      /** @description Input list of one or more bibcodes
       *      */
      bibcode: string[];
    };
    bibcodesObject: {
      /** @description Input list of one or more bibcodes
       *      */
      bibcodes: string[];
    };
    basicMetricsResponse: {
      'basic stats'?: {
        'average number of downloads'?: number;
        'average number of reads'?: number;
        'median number of downloads'?: number;
        'median number of reads'?: number;
        'normalized paper count'?: number;
        'number of papers'?: number;
        'recent number of downloads'?: number;
        'recent number of reads'?: number;
        'total number of downloads'?: number;
        'total number of reads'?: number;
      };
      'basic stats refereed'?: {
        'average number of downloads'?: number;
        'average number of reads'?: number;
        'median number of downloads'?: number;
        'median number of reads'?: number;
        'normalized paper count'?: number;
        'number of papers'?: number;
        'recent number of downloads'?: number;
        'recent number of reads'?: number;
        'total number of downloads'?: number;
        'total number of reads'?: number;
      };
      'citation stats'?: {
        'average number of citations'?: number;
        'average number of refereed citations'?: number;
        'median number of citations'?: number;
        'median number of refereed citations'?: number;
        'normalized number of citations'?: number;
        'normalized number of refereed citations'?: number;
        'number of citing papers'?: number;
        'number of self-citations'?: number;
        'self-citations'?: string[];
        'total number of citations'?: number;
        'total number of refereed citations'?: number;
      };
      'citation stats refereed'?: {
        'average number of citations'?: number;
        'average number of refereed citations'?: number;
        'median number of citations'?: number;
        'median number of refereed citations'?: number;
        'normalized number of citations'?: number;
        'normalized number of refereed citations'?: number;
        'number of citing papers'?: number;
        'number of self-citations'?: number;
        'self-citations'?: string[];
        'total number of citations'?: number;
        'total number of refereed citations'?: number;
      };
      histograms?: {
        citations?: {
          'nonrefereed to nonrefereed'?: {
            year?: number;
          };
          'nonrefereed to nonrefereed normalized'?: {
            year?: number;
          };
          'nonrefereed to refereed'?: {
            year?: number;
          };
          'nonrefereed to refereed normalized'?: {
            year?: number;
          };
          'refereed to nonrefereed'?: {
            year?: number;
          };
          'refereed to nonrefereed normalized'?: {
            year?: number;
          };
          'refereed to refereed'?: {
            year?: number;
          };
          'refereed to refereed normalized'?: {
            year?: number;
          };
        };
        reads?: {
          'all reads'?: {
            year?: number;
          };
          'all reads normalized'?: {
            year?: number;
          };
          'refereed reads'?: {
            year?: number;
          };
          'refereed reads normalized'?: {
            year?: number;
          };
        };
      };
      'skipped bibcodes'?: string[];
    };
    summary: {
      master?: {
        bibstem?: string;
        journal_name?: string;
        primary_language?: string;
        multilingual?: boolean;
        defunct?: boolean;
        pubtype?: string;
        refereed?: string;
        collection?: string;
        notes?: string;
        not_indexed?: boolean;
      };
      idents?: {
        id_type?: string;
        id_value?: string;
      }[];
      abbrev?: string[];
      pubhist?: {
        publisher?: string;
        title?: {
          year_start?: number;
          year_end?: number;
          vol_start?: string;
          vol_end?: string;
          complete?: string;
          successor_masterid?: number;
          notes?: string;
        };
      }[];
      names?: {
        name_english_translated?: string;
        title_language?: string;
        name_native_language?: string;
        name_normalized?: string;
      };
    };
    journal: {
      journal?: {
        bibstem?: string;
        name?: string;
      }[];
    };
    holdings: {
      bibstem?: string;
      volume?: string;
      numFound?: number;
      holdings?: {
        esources?: string[];
        page?: string;
      }[];
    };
    refsource: {
      refsource?: {
        bibstem?: string;
        volumes?: {
          volume?: string;
          year?: string;
          refsources?: {
            AUTHOR?: number;
            OTHER?: number;
            ISI?: number;
            CROSSREF?: number;
            OCR?: number;
            PUBLISHER?: number;
          };
        }[];
      };
    };
    issn: {
      issn?: {
        ISSN?: string;
        ISSN_type?: string;
        bibstem?: string;
        journal_name?: string;
      };
    };
    myADSsummaryResponse: {
      active?: boolean;
      created?: string;
      data?: string;
      /** @enum {string} */
      frequency?: 'daily' | 'weekly';
      id?: number;
      name?: string;
      /** @enum {string} */
      template?: 'arxiv' | 'authors' | 'citations' | 'keyword';
      /** @enum {string} */
      type?: 'template' | 'query';
      updated?: string;
    };
    myADSdetailResponse: {
      qid?: string;
      stateful?: boolean;
      classes?: string[];
    };
  };
  responses: {
    /** @description Results returned by the search engine */
    SearchResults: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['results'];
      };
    };
    /** @description Abstract Syntax Tree of a Parsed query */
    QTree: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['qtree'];
      };
    };
    /** @description Response from vault storage service */
    VaultResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Number of docs this query found (the last time it was executed; this number is up to date only when the query is stored). But if you see number higher than 0 then you can be sure that the query was executed.
           *      */
          readonly numfound?: number;
          /** @description Query ID (unique hash identifying all the parameters; it is computed from the supplied query parameters)
           *      */
          readonly qid?: string;
          /** @description Serialized JSON input search parameters
           *      */
          query?: string;
        };
      };
    };
    /** @description Returns export
     *      */
    ExportResponseGet: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': string;
      };
    };
    /** @description Returns export
     *      */
    ExportResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          msg?: string;
          export?: string;
        };
      };
    };
    /** @description JSON containing the available external resources, including links
     *      */
    ResolverResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          action?: string;
          links?: {
            count?: number;
            link_type?: string;
            records?: {
              bibcode?: string;
              count?: number;
              title?: string;
              type?: string;
              url?: string;
            }[];
          };
        };
      };
    };
  };
  parameters: {
    /**
     * @description Query string; for detailed documentation go to https://ui.adsabs.harvard.edu/help/search/search-syntax
     * @example author%3Amart%C3%ADnez+neutron+star
     */
    q: string;
    /** @description Additional filters applied on top of the results of the main query. */
    fq: string[];
    /**
     * @description Comma delimited set of fields to return; default is 'id'
     * @example bibcode,author,title
     */
    fl: (
      | 'abstract'
      | 'ack'
      | 'aff'
      | 'aff_id'
      | 'alternate_bibcode'
      | 'alternate_title'
      | 'arxiv_class'
      | 'author'
      | 'author_count'
      | 'author_norm'
      | 'bibcode'
      | 'bibgroup'
      | 'bibstem'
      | 'citation'
      | 'citation_count'
      | 'cite_read_boost'
      | 'classic_factor'
      | 'comment'
      | 'copyright'
      | 'data'
      | 'database'
      | 'date'
      | 'doctype'
      | 'doi'
      | 'eid'
      | 'entdate'
      | 'entry_date'
      | 'esources'
      | 'facility'
      | 'first_author'
      | 'first_author_norm'
      | 'grant'
      | 'grant_agencies'
      | 'grant_id'
      | 'id'
      | 'identifier'
      | 'indexstamp'
      | 'inst'
      | 'isbn'
      | 'issn'
      | 'issue'
      | 'keyword'
      | 'keyword_norm'
      | 'keyword_schema'
      | 'lang'
      | 'links_data'
      | 'nedid'
      | 'nedtype'
      | 'orcid_pub'
      | 'orcid_other'
      | 'orcid_user'
      | 'page'
      | 'page_count'
      | 'page_range'
      | 'property'
      | 'pub'
      | 'pub_raw'
      | 'pubdate'
      | 'pubnote'
      | 'read_count'
      | 'reference'
      | 'simbid'
      | 'title'
      | 'vizier'
      | 'volume'
      | 'year'
    )[];
    /** @description For pagination, offset of the first returned result (default=0) */
    start: number;
    /** @description How many records to return for this request (default=10, maximum=2000) */
    rows: number;
    /** @description The format is 'field' + 'direction' where direction is one of 'asc' or 'desc' and field is any of the valid indexes. The default sorting is by relevance (computed by our search engine). Example\: 'sort=read_count+desc' Some useful fields to sort by may be date, citation_count, or read_count.
     *      */
    sort:
      | 'id asc'
      | 'author_count asc'
      | 'bibcode asc'
      | 'citation_count asc'
      | 'citation_count_norm asc'
      | 'classic_factor asc'
      | 'first_author asc'
      | 'date asc'
      | 'entry_date asc'
      | "read_count asc'"
      | 'score asc'
      | 'id desc'
      | 'author_count desc'
      | 'bibcode desc'
      | 'citation_count desc'
      | 'citation_count_norm desc'
      | 'classic_factor desc'
      | 'first_author desc'
      | 'date desc'
      | 'entry_date desc'
      | 'read_count desc'
      | 'score desc';
    /** @description QID returned from the POST operation */
    queryId: string;
    /** @description Bibcode to export */
    bibcode: string;
    /** @description Query URL */
    link: string;
    /**
     * @description (Case-sensitive) ADS identifier for a publication, used to create bibcodes
     *
     * @example ApJS
     */
    JournalBibstem: string;
    /**
     * @description Search string
     * @example Astro%20Jour
     */
    JournalJournalName: string;
    /** @description publication volume */
    JournalVolume: string;
    /**
     * @description Search string
     * @example 0004-637X
     */
    JournalISSN: string;
    /** @description ID from one myADS notification, taken from the response to `/vault/notifications` */
    myadsId: number;
  };
  requestBodies: {
    /** @description JSON containing the bibcodes to export
     *      */
    exportBody: {
      content: {
        'application/json': components['schemas']['bibcodeObject'];
      };
    };
  };
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
